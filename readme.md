# Паттерн Одиночка
## Классическая реализация паттерна Одиночка
![Kartinka1](https://github.com/Kezhik-61/Singleton/blob/master/img/5.PNG?raw=true)
## Паттерны для	всех

 **_Интервью недели: Признания Одиночки_**

**HeadFirst:**   Сегодня вниманию  слушателей предлагается интервью  с объектом Одиночкой. Может, 
немного расскажете о себе?

**Одиночка:** Я единственный и неповторимый!

**HeadFirst:** Неужели?

**Одиночка:** Да. Я создан на основе паттерна Одиночка, а это гарантирует, что в любой момент времени 
существует только один экземпляр моего класса.

**HeadFirst:** Разве это не расточительно? Кто-то тратит время на создание класса, а потом по этому опи-
санию создается всего один объект?

**Одиночка:** Вовсе нет! Во многих случаях существование одиночных объектов оправдано. Предполо-
жим, в объекте хранятся настройки реестра. Если кто-то создаст несколько экземпляров такого объ-
екта, это может привести к хаосу. Одиночные объекты гарантируют, что все компоненты вашего при-
ложения будут использовать один и тот же глобальный ресурс.

**HeadFirst:** Продолжайте...

**Одиночка:** О, я отлично подхожу для подобных задач. Одиночество имеет свои преимущества. Меня 
часто используют для управления пулами ресурсов — скажем, подключений или программных потоков. 

**HeadFirst:** И все-таки — быть всегда одним? Вам не скучно?

**Одиночка:** Так как мне никто не помогает, скучать некогда. Но разработчикам не помешало бы получ-
ше изучить меня — во многих программах возникают ошибки, когда в системе создаются дополнитель-
ные экземпляры объектов, о которых их создатель и не подозревает.

**HeadFirst:** Но как можно быть уверенным в том, что вы существуете в одном экземпляре? Разве любой 
желающий не сможет создать новый экземпляр оператором new?

**Одиночка:**  Нет! Я абсолютно уникален.

**HeadFirst:** Разработчики торжественно клянутся не создавать более одного экземпляра?

**Одиночка:** Нет, конечно. Возможно, это дело личное, но... у меня нет открытого конструктора.

**HeadFirst:** НЕТ ОТКРЫТОГО КОНСТРУКТОРА?! Ох, извините... неужели нет?

**Одиночка:** Вот именно. Мой конструктор объявлен приватным..

**HeadFirst:** И как работает эта схема? Как ВООБЩЕ можно создать экземпляр?

**Одиночка:** Чтобы получить объект, вы не создаете его экземпляр, а *запрашиваете* его. Мой класс со-
держит статический метод с именем getInstance(). Вызовите его, и вы получите экземпляр, готовый 
к работе. Может оказаться, что к этому моменту я уже существую и обслуживаю другие объекты.

**HeadFirst:**   Похоже, в этой схеме многое остается скрытым от посторонних глаз! Спасибо, что при-
няли наше приглашение. Надеемся, наша беседа скоро продолжится!

## Шоколадная фабрика 
Всем известно, что на  всех  современных шоколадных фабриках используются 
нагреватели  с  компьютерным  управлением. Смесь шоколада и молока  в  таком 
нагревателе доводится до кипения и передается на  следующий  этап изготовле-
ния шоколадных  батончиков. Ниже  приведен  код  класса,  управляющего Choc-
O-Holic — мощным высокопроизводительным нагревателем для шоколада. Про-
смотрите код; вы заметите, что автор постарался сделать все возможное, чтобы 
избежать некоторых неприятностей — скажем, слива холодной смеси, перепол-
нения или нагревания пустой емкости!

![Kartink2](https://github.com/Kezhik-61/Singleton/blob/master/img/6.PNG?raw=true)

## Определение паттерна Одиночка

**Итак, вы познакомились с классической реализацией паттерна Одиночка. Сейчас можно 
устроиться поудобнее, съесть шоколадку и перейти к рассмотрению некоторых нюансов 
паттерна Одиночка.**

**Начнем с формального определения паттерна:**

           |------------------------------------|
           | **Паттерн Одиночка** гарантирует,  |
           |что класс имеет только один экземпл-|
           |яр, и предоставляет глобальную точку|
           |доступа к этому экземпляру.         |
           |------------------------------------|
**Пока ничего особенного. Но давайте присмотримся повнимательнее:**

* Что здесь по сути происходит? Мы берем существующий класс и разрешаем ему соз-
дать только один экземпляр. Кроме того, мы запрещаем любым другим классам про-
извольно создавать новые экземпляры этого класса. Чтобы получить экземпляр, не-
обходимо обратиться с запросом к самому классу.

*  Кроме  того,  паттерн  предоставляет  глобальную  точку  доступа  к  экземпляру:  об-
ратившись с запросом к классу в любой точке программы, вы получите   ссылку на 
единственный экземпляр. Как было показано выше, возможно отложенное создание 
экземпляра, что особенно важно для объектов, создание которых сопряжено с боль-
шими затратами ресурсов.

**Обратимся к диаграмме классов:**

![Kartinka3](https://github.com/Kezhik-61/Singleton/blob/master/img/7.PNG?raw=true)












